name: Build & Release

on:
  push:
    branches: [main, build-matrix]
  workflow_dispatch:
    inputs:
      bump_version:
        description: 'Bump version and create release'
        required: false
        default: 'none'
        type: choice
        options:
          - none
          - patch
          - minor
          - major

jobs:
  # Check version and optionally bump it
  check-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      should_release: ${{ steps.check.outputs.should_release }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bump version (if requested)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.bump_version != 'none'
        id: bump
        run: |
          CURRENT_VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "Current version: $CURRENT_VERSION"

          # Parse version (assuming semver X.Y.Z)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          case "${{ github.event.inputs.bump_version }}" in
            patch)
              PATCH=$((PATCH + 1))
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "New version: $NEW_VERSION"
          echo "$NEW_VERSION" > VERSION

      - name: Commit and push version bump
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.bump_version != 'none'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Bump version to ${{ steps.bump.outputs.new_version }}"
          file_pattern: VERSION
          commit_user_name: ${{ github.actor }}
          commit_user_email: ${{ github.actor }}@users.noreply.github.com
          commit_author: ${{ github.actor }} <${{ github.actor }}@users.noreply.github.com>

      - name: Read VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Current VERSION: ${VERSION}"

      - name: Check if should create release
        id: check
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Check if version tag exists
          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "â­ï¸  Version v${VERSION} already has a release"
            SHOULD_RELEASE=false
          else
            echo "âœ… Version v${VERSION} does not have a release"
            SHOULD_RELEASE=true
          fi

          # Only release on manual trigger AND version doesn't have tag
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "$SHOULD_RELEASE" == "true" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "ðŸš€ Will create release for v${VERSION}"
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "â­ï¸  Skipping release"
          fi

  # Build Docker image once (shared by all matrix jobs)
  build-docker:
    needs: [check-version]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and cache Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          tags: usbretro:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Build all products (matrix: 4 boards)
  build:
    needs: [build-docker]
    runs-on: ubuntu-latest

    strategy:
      matrix:
        board: [rpi_pico, ada_qtpy, ada_kb2040, waveshare_rp2040_zero]

    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Load Docker image from cache
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: usbretro:latest
          cache-from: type=gha

      - name: Compile all apps for ${{ matrix.board }}
        run: |
          echo "Building all apps for ${{ matrix.board }}..."

          docker run --rm \
            -v ${{ github.workspace }}/src/build:/root/workspace/USBRetro/src/build \
            usbretro:latest /bin/bash -c "
              cd /root/workspace/USBRetro/src &&
              sh build_${{ matrix.board }}.sh &&
              cd build &&
              cmake .. &&
              make usbretro_pce usbretro_ngc usbretro_nuon usbretro_xb1 usbretro_loopy usbretro_3do -j4
            "

          # Fix permissions (Docker creates files as root)
          sudo chown -R $(id -u):$(id -g) src/build/

      - name: Rename firmware with commit hash and board
        run: |
          COMMIT_HASH=$(echo ${{ github.sha }} | cut -c1-7)
          echo "COMMIT_HASH=${COMMIT_HASH}" >> $GITHUB_ENV
          mkdir -p artifacts

          # Map console names to app names
          declare -A APP_NAMES
          APP_NAMES[pce]="usb2pce"
          APP_NAMES[ngc]="usb2gc"
          APP_NAMES[nuon]="usb2nuon"
          APP_NAMES[xb1]="usb2xb1"
          APP_NAMES[loopy]="usb2loopy"
          APP_NAMES[3do]="usb23do"

          # Rename all .uf2 files: usbr_<commit>_<board>_<app>.uf2
          for file in src/build/*.uf2; do
            if [ -f "$file" ]; then
              filename=$(basename "$file" .uf2)
              # Extract console name from filename (e.g., usbretro_pce -> pce)
              console=$(echo "$filename" | sed 's/usbretro_//')
              app_name="${APP_NAMES[$console]:-$console}"
              mv "$file" "artifacts/usbr_${COMMIT_HASH}_${{ matrix.board }}_${app_name}.uf2"
            fi
          done

          echo "Renamed firmware files for ${{ matrix.board }}:"
          ls -lh artifacts/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: usbretro_${{ env.COMMIT_HASH }}_${{ matrix.board }}
          path: artifacts/*.uf2

  # Create GitHub Release (only if check-version says we should)
  create-release:
    needs: [check-version, build]
    if: needs.check-version.outputs.should_release == 'true' && needs.build.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download kb2040 artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: usbretro_*_ada_kb2040
          path: artifacts

      - name: Prepare release package
        run: |
          mkdir -p release
          VERSION="${{ needs.check-version.outputs.version }}"

          echo "ðŸ“¦ Preparing v${VERSION} release from kb2040 builds:"

          # Find and rename the stable app firmware files: usbr_<version>_<app>.uf2
          find artifacts -name "usbr_*_ada_kb2040_usb2pce.uf2" -exec cp {} release/usbr_${VERSION}_usb2pce.uf2 \;
          find artifacts -name "usbr_*_ada_kb2040_usb2gc.uf2" -exec cp {} release/usbr_${VERSION}_usb2gc.uf2 \;
          find artifacts -name "usbr_*_ada_kb2040_usb2nuon.uf2" -exec cp {} release/usbr_${VERSION}_usb2nuon.uf2 \;

          echo ""
          echo "âœ… Release package contents:"
          ls -lh release/

          # Create checksums
          cd release
          sha256sum * > checksums.txt
          echo ""
          echo "ðŸ” Checksums:"
          cat checksums.txt

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.version }}
          name: USBRetro v${{ needs.check-version.outputs.version }}
          body: |
            ## Installation

            **usb2pce / usb2nuon:**
            1. Disconnect adapter from console and all USB devices
            2. Hold BOOT button while connecting USB-C to computer
            3. Drag & drop `.uf2` file to `RPI-RP2` drive
            4. Drive will auto-eject when complete

            **usb2gc:**
            1. Disconnect adapter from console and all USB devices
            2. Connect USB-C to computer (no BOOT button needed)
            3. Drag & drop `.uf2` file to `RPI-RP2` drive
            4. Drive will auto-eject when complete
          files: |
            release/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          VERSION="${{ needs.check-version.outputs.version }}"
          echo "### âœ… Release v${VERSION} Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`v${VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Apps:** usb2pce, usb2gc, usb2nuon" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ **Release contents:**" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          ls -lh release/ >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
